{
  "reports": [
    {
      "id": "5",
      "title": "VTK Source Classes in generated_nodes/gen_VTKSources.py",
      "content": "# VTK Source Classes in generated_nodes/gen_VTKSources.py\n\nThis community centers around the Python module GENERATED_NODES/GEN_VTKSOURCES.PY, which serves as a centralized repository for numerous VTK (Visualization Toolkit) source classes used in scientific visualization and simulation pipelines. The module defines a wide array of data generators, including image sources (e.g., Gaussian, Mandelbrot, noise), geometric primitives (e.g., Platonic solids, planes, polygons), and specialized sources like hyper tree grid generators and programmable data objects. Nearly all listed VTK source entities are implemented within this single file, indicating a highly modular and auto-generated software architecture. One notable external relationship exists between VTKPlaneSource and VTKStreamTracer, where the former supplies seed geometry for streamline generation.\n\n## Central role of GENERATED_NODES/GEN_VTKSOURCES.PY as a code repository\n\nThe module GENERATED_NODES/GEN_VTKSOURCES.PY functions as the central architectural hub for this community, encapsulating the definitions of dozens of VTK source classes. It is described as a programmatically maintained or auto-generated file that consolidates both image-specific and general-purpose data source components under a single organized location. This design suggests integration within a larger code generation framework, possibly used to produce node definitions for visualization or simulation systems. The module’s high degree centrality (degree 35) underscores its structural importance. [Data: Entities (519); Relationships (517, 518, 519, 520, 521, +more)]\n\n## Diverse range of VTK image source implementations\n\nThe community includes a comprehensive suite of VTK image source classes, each designed to generate specific types of synthetic or procedural image data. Examples include VTKImageGaussianSource (for Gaussian-distributed data), VTKImageMandelbrotSource (for fractal images), VTKImageNoiseSource (for random noise), and VTKImageSinusoidSource (for wave-like patterns). Other image sources like VTKImageEllipsoidSource and VTKImageCanvasSource2D support geometric and drawing-based image creation. All these classes are explicitly defined within the GENERATED_NODES/GEN_VTKSOURCES.PY module, highlighting its role in supporting varied visualization workflows that require controlled or synthetic image inputs. [Data: Entities (516, 517, 518, 521, 523, 524, 525, 526, 527); Relationships (519, 520, 521, 526, 527)]\n\n## Specialized hyper tree grid source classes for hierarchical data\n\nMultiple VTK source classes in this community are dedicated to generating hyper tree grid data structures, which are used for efficient representation of adaptive, hierarchical volumetric data. These include VTKHyperTreeGridPreConfiguredSource, VTKHyperTreeGridSource, VTKRandomHyperTreeGridSource, and VTKUniformHyperTreeGridSource. Each offers distinct configuration options—for instance, VTKRandomHyperTreeGridSource supports parameters like m_Seed and m_Dimensions, while VTKUniformHyperTreeGridSource allows control over branch factor and grid scale. Their presence indicates support for advanced scientific visualization tasks involving multi-resolution or adaptive mesh data. All are implemented in the same central module. [Data: Entities (514, 515, 539, 555); Relationships (517, 518, 542, 547)]\n\n## Geometric and parametric source primitives for 3D visualization\n\nThe community includes numerous VTK classes that generate fundamental geometric shapes and parametric surfaces, essential for building visualization scenes or simulation inputs. These include VTKPlatonicSolidSource (for regular polyhedra), VTKPlaneSource (for flat polygonal surfaces), VTKRegularPolygonSource, VTKRectangularButtonSource, and VTKParametricFunctionSource (for user-defined parametric surfaces). VTKPlaneSource, in particular, is noted for its role in providing seed geometry to vtkStreamTracer for generating streamlines in vector field visualizations. These primitives demonstrate the module’s utility in creating base geometries for downstream processing. [Data: Entities (69, 530, 540, 541, 527); Relationships (186, 533, 543, 544, 529)]\n\n## Programmable and utility sources for flexible data pipelines\n\nBeyond fixed-function generators, the module includes flexible source types that enable custom or dynamic data generation. VTKProgrammableDataObjectSource allows users to define their own data object creation logic, offering extensibility for bespoke visualization needs. Other utility classes like VTKWindowToImageFilter and VTKResizingWindowToImageFilter convert rendered output into image data, supporting screenshot or post-processing workflows. VTKVideoSource simulates or captures video input, while VTKWordCloud generates textual visualizations from input files. These components illustrate the module’s support for both interactive and automated visualization pipelines. [Data: Entities (536, 558, 542, 557, 559); Relationships (539, 550, 545, 549, 551)]\n\n## Evidence of auto-generated or templated code structure\n\nThe naming convention, consistent implementation location, and descriptive patterns across entities strongly suggest that the contents of GENERATED_NODES/GEN_VTKSOURCES.PY are auto-generated or produced via a code generation framework. The file path itself ('generated_nodes') and the repetitive structure of class definitions—each tied to the same module with similar property schemas—support this inference. This approach enables scalable maintenance and consistent interfacing of VTK source nodes, likely within a larger visual programming or simulation environment where nodes are assembled into dataflow pipelines. [Data: Entities (519); Relationships (517, 518, 519, 520, 521, +more)]\n\n## Integration with VTKStreamTracer via VTKPlaneSource\n\nWhile most relationships in the community are unidirectional links from source classes to the central module, one notable external dependency exists: VTKPlaneSource supplies seed points (as input 1) to VTKStreamTracer for streamline generation. This indicates that at least one component in this community interacts directly with another part of the VTK ecosystem beyond the gen_VTKSources.py module. VTKPlaneSource’s planar geometry is particularly well-suited for seeding streamlines in fluid dynamics or field visualization, demonstrating a functional integration point that extends the community’s relevance into simulation and analysis workflows. [Data: Entities (69); Relationships (186)]"
    }
  ],
  "entities": [
    {
      "id": "515",
      "entity": "VTKHYPERTREEGRIDSOURCE",
      "description": "A VTK source class in generated_nodes/gen_VTKSources.py that generates hyper tree grids with customizable parameters like m_BranchFactor and m_MaxDepth",
      "number of relationships": "1",
      "in_context": true
    },
    {
      "id": "539",
      "entity": "VTKRANDOMHYPERTREEGRIDSOURCE",
      "description": "VTKRandomHyperTreeGridSource is a VTK source class for generating random hyper tree grid data, defined in generated_nodes/gen_VTKSources.py with properties like m_MaxDepth, m_Seed, and m_Dimensions",
      "number of relationships": "1",
      "in_context": true
    },
    {
      "id": "123",
      "entity": "COLOR MAPPER.001",
      "description": "Color Mapper.001 is a second instance of a color mapping component that applies color to the output of vtkGlyph3D based on scalar data",
      "number of relationships": "1",
      "in_context": true
    },
    {
      "id": "555",
      "entity": "VTKUNIFORMHYPERTREEGRIDSOURCE",
      "description": "A VTK source class defined in gen_VTKSources.py that generates uniform hyper tree grids with configurable properties such as branch factor, max depth, and grid scale",
      "number of relationships": "1",
      "in_context": true
    },
    {
      "id": "514",
      "entity": "VTKHYPERTREEGRIDPRECONFIGUREDSOURCE",
      "description": "A VTK source class defined in generated_nodes/gen_VTKSources.py with properties such as m_ObjectName and m_CustomDepth; used for pre-configured hyper tree grid generation",
      "number of relationships": "1",
      "in_context": true
    },
    {
      "id": "6",
      "entity": "COLOR RAMP",
      "description": "Color Ramp is a visualization node in Blender’s VTK (Visualization Toolkit) integration that defines a configurable lookup table—often implemented as a color gradient—for mapping scalar data values to corresponding colors within a visualization pipeline. It serves as a core component used by the Color Mapper to assign colors based on data values, enabling effective representation of field or scalar data in rendered visualizations. The node supports customization through user-defined parameters and can incorporate textures or color gradients as the basis for its mapping. It offers flexibility by including presets derived from matplotlib, allowing users to quickly apply established color schemes. Additionally, the Color Ramp node can accommodate up to 32 discrete color samples, providing sufficient resolution for nuanced data representation. Functionally, it operates within VTK-based visualization workflows, generating a lookup table that translates numerical input ranges into a continuous or segmented spectrum of colors. This capability makes it essential for scientific visualization tasks where accurate and intuitive color encoding of data is critical. The node may also feature custom code and texture name attributes, further enhancing its adaptability to specific visualization needs. Overall, Color Ramp acts as a bridge between raw scalar data and its visual interpretation, ensuring that data-driven color mapping is both precise and visually meaningful in the rendering pipeline.",
      "number of relationships": "3",
      "in_context": true
    },
    {
      "id": "7",
      "entity": "COLOR MAPPER",
      "description": "Color Mapper is a visualization node used in Blender’s VTK-based rendering pipeline that maps scalar or field data values to visual color representations. It functions by applying a lookup table—often sourced from a connected Color Ramp node—to translate numerical data attributes into corresponding colors for rendering purposes. This node allows users to define how data is colored through properties such as \"color_by,\" which specifies the data array or attribute to map, and may also support custom code for advanced color mapping logic. Typically integrated within visualization workflows, Color Mapper connects to other VTK components such as vtkCutter and receives input from nodes that provide scalar data or texture settings. Its primary role is to enhance data interpretability by converting abstract numerical values into intuitive color gradients, making it a key element in scientific and engineering visualizations where scalar fields—such as temperature, pressure, or velocity—need to be visually represented. The node consistently operates using a lookup table mechanism, ensuring a coherent and flexible approach to color assignment based on selected data arrays or scalar attributes.",
      "number of relationships": "7",
      "in_context": true
    },
    {
      "id": "519",
      "entity": "GENERATED_NODES/GEN_VTKSOURCES.PY",
      "description": "GENERATED_NODES/GEN_VTKSOURCES.PY is a file path and Python module within a software project that serves as a centralized location for the implementation and definitions of multiple VTK (Visualization Toolkit) source classes. This module functions as a digital, geo-like entity in the software architecture, encapsulating various source components used for generating synthetic or procedural data in VTK-based visualization pipelines. The file contains the code for a range of VTK source classes, including but not limited to vtkRTAnalyticSource, vtkRandomHyperTreeGridSource, vtkHyperTreeGridPreConfiguredSource, and vtkImageGaussianSource. These classes represent different types of data generators—such as analytic functions, random hyper tree grids, and Gaussian image sources—commonly employed in scientific visualization and computational geometry workflows. In addition to these specific implementations, the module also includes definitions for various VTK image source classes, further broadening its role in supporting diverse data generation needs. As suggested by its name and content, GENERATED_NODES/GEN_VTKSOURCES.PY appears to be auto-generated or programmatically maintained, likely as part of a larger code generation framework that produces node definitions for use in a visualization or simulation system. The consistent references across all descriptions confirm that this module is a key repository for VTK source node logic, consolidating both image-specific and general-purpose source components under a single, organized file path.",
      "number of relationships": "35",
      "in_context": true
    },
    {
      "id": "521",
      "entity": "VTKIMAGEGRIDSOURCE",
      "description": "A VTK class for generating grid-like image patterns, part of the VTKSources module",
      "number of relationships": "1",
      "in_context": true
    },
    {
      "id": "525",
      "entity": "VTKIMAGESINUSOIDSOURCE",
      "description": "A VTK class that generates sinusoidal image patterns, part of the VTK image source components",
      "number of relationships": "1",
      "in_context": true
    },
    {
      "id": "15",
      "entity": "COLORRAMP",
      "description": "Color Ramp provides a lookup table used by the Color Mapper to assign colors based on data values",
      "number of relationships": "1",
      "in_context": true
    },
    {
      "id": "541",
      "entity": "VTKREGULARPOLYGONSOURCE",
      "description": "VTKRegularPolygonSource is a VTK source class for generating regular polygon or polyline geometry, defined in generated_nodes/gen_VTKSources.py with properties like m_NumberOfSides, m_Radius, and m_Normal",
      "number of relationships": "1",
      "in_context": true
    },
    {
      "id": "527",
      "entity": "VTKPARAMETRICFUNCTIONSOURCE",
      "description": "A VTK source node defined in generated_nodes/gen_VTKSources.py used to generate parametric surfaces with properties like m_GenerateNormals and m_UResolution",
      "number of relationships": "1",
      "in_context": true
    },
    {
      "id": "14",
      "entity": "COLORMAPPER",
      "description": "Color Mapper is a visualization component that maps scalar data to colors using a lookup table",
      "number of relationships": "3",
      "in_context": true
    }
  ],
  "relationships": [
    {
      "id": "5",
      "source": "COLOR RAMP",
      "target": "COLOR MAPPER",
      "description": "COLOR RAMP and COLOR MAPPER are closely integrated components within a data visualization or rendering system, working together to translate numerical or categorical data values into visual color representations. The COLOR RAMP serves as the source of a lookup table that defines a sequence or range of colors, which is then utilized by the COLOR MAPPER to assign specific colors to corresponding data values. In essence, the COLOR RAMP configures or feeds into the COLOR MAPPER by providing the necessary color gradient or palette that dictates how data should be visually encoded. This lookup table supplied by the COLOR RAMP enables the COLOR MAPPER to perform its core function: mapping individual data points or ranges to appropriate colors based on the predefined scheme. The relationship between the two is hierarchical and functional—the COLOR RAMP establishes the visual rules through its color definitions, while the COLOR MAPPER executes the application of those rules to the dataset in question. Together, they ensure a consistent, interpretable, and visually meaningful representation of data through color.",
      "weight": "8.0",
      "links": "1",
      "in_context": true
    },
    {
      "id": "7",
      "source": "COLOR MAPPER",
      "target": "COLOR RAMP",
      "description": "Color Ramp and Color Mapper are two closely integrated components in a visualization system, where Color Ramp serves as the source of the lookup table that defines the color scale, and Color Mapper utilizes this lookup table to perform color mapping. Specifically, Color Ramp supplies the lookup table used by Color Mapper to map scalar data values to corresponding colors, enabling effective visual encoding of numerical information. This lookup table defines how a range of scalar values is translated into a continuous or discrete spectrum of colors, which is essential for representing data gradients or categories in visualizations such as heatmaps, volume renderings, or surface plots. The connection between the two components is direct: Color Ramp is linked to the lookup table input of Color Mapper, ensuring that any adjustments to the color scale in Color Ramp are immediately reflected in the output of Color Mapper. Through this relationship, Color Mapper applies the visual mapping defined by Color Ramp to transform raw scalar data into a color-encoded representation that enhances interpretability and aesthetic clarity in data visualization workflows.",
      "weight": "39.0",
      "links": "1",
      "in_context": true
    },
    {
      "id": "517",
      "source": "VTKHYPERTREEGRIDPRECONFIGUREDSOURCE",
      "target": "GENERATED_NODES/GEN_VTKSOURCES.PY",
      "description": "VTKHyperTreeGridPreConfiguredSource is implemented in the module generated_nodes/gen_VTKSources.py",
      "weight": "9.0",
      "links": "4",
      "in_context": true
    },
    {
      "id": "518",
      "source": "VTKHYPERTREEGRIDSOURCE",
      "target": "GENERATED_NODES/GEN_VTKSOURCES.PY",
      "description": "VTKHyperTreeGridSource is implemented in the module generated_nodes/gen_VTKSources.py",
      "weight": "9.0",
      "links": "4",
      "in_context": true
    },
    {
      "id": "542",
      "source": "VTKRANDOMHYPERTREEGRIDSOURCE",
      "target": "GENERATED_NODES/GEN_VTKSOURCES.PY",
      "description": "VTKRandomHyperTreeGridSource is defined in the module generated_nodes/gen_VTKSources.py",
      "weight": "9.0",
      "links": "4",
      "in_context": true
    },
    {
      "id": "547",
      "source": "GENERATED_NODES/GEN_VTKSOURCES.PY",
      "target": "VTKUNIFORMHYPERTREEGRIDSOURCE",
      "description": "VTKUniformHyperTreeGridSource is defined within the gen_VTKSources.py module",
      "weight": "9.0",
      "links": "4",
      "in_context": true
    },
    {
      "id": "33",
      "source": "VTKGLYPH3D",
      "target": "COLOR MAPPER",
      "description": "vtkGlyph3D outputs glyphed geometry that is colored by the Color Mapper",
      "weight": "9.0",
      "links": "3",
      "in_context": true
    },
    {
      "id": "583",
      "source": "VTKGLYPH3D",
      "target": "COLOR RAMP",
      "description": "vtkGlyph3D produces geometry that is colored using the Color Ramp node’s gradient mapping",
      "weight": "6.0",
      "links": "3",
      "in_context": true
    },
    {
      "id": "206",
      "source": "VTKGLYPH3D",
      "target": "COLOR MAPPER.001",
      "description": "vtkGlyph3D’s output is sent to Color Mapper.001 for color mapping",
      "weight": "1.0",
      "links": "3",
      "in_context": true
    },
    {
      "id": "8",
      "source": "COLOR MAPPER",
      "target": "VTK TO BLENDER MESH",
      "description": "The COLOR MAPPER and VTK TO BLENDER MESH are two interconnected components in a visualization or data conversion pipeline, typically used to transform scientific or geometric data into a format compatible with Blender, a popular 3D modeling and animation software. The COLOR MAPPER is responsible for generating or assigning color information to geometric data based on scalar values or other mapped attributes. This color mapping is often achieved through a lookup table, which translates numerical data into a visual color spectrum. The output of the COLOR MAPPER is a colored geometry representation that includes both spatial and chromatic information.\n\nThis colored geometry is then passed to the VTK TO BLENDER MESH component, which handles the conversion of Visualization Toolkit (VTK)-formatted data into a mesh structure that Blender can interpret and render. The VTK TO BLENDER MESH node receives the color-mapped data—either as part of the geometry itself or via a dedicated lookup table connector—and ensures that the color information is properly incorporated into the final mesh representation within Blender. This integration allows the resulting mesh not only to retain its geometric fidelity but also to display the color variations assigned by the COLOR MAPPER, enabling visually informative and accurate 3D visualizations.\n\nIn summary, the COLOR MAPPER provides color-mapped geometric data—either directly as colored geometry or through a lookup table interface—to the VTK TO BLENDER MESH component, which then converts this data into a Blender-compatible mesh while preserving the color information. This workflow facilitates the seamless transition of scientific or simulation data from VTK-based processing environments into Blender for advanced rendering, animation, or presentation purposes. The relationship between the two components is sequential and interdependent: the COLOR MAPPER prepares the visual attributes, and the VTK TO BLENDER MESH translates both geometry and color into a usable 3D asset within Blender.",
      "weight": "29.0",
      "links": "1",
      "in_context": true
    },
    {
      "id": "183",
      "source": "VTKCUTTER",
      "target": "COLOR MAPPER",
      "description": "vtkCutter and Color Mapper are components in a visualization pipeline where vtkCutter is responsible for generating cross-sectional geometry from input data, and the Color Mapper handles the assignment of colors to that geometry based on associated data values. Specifically, vtkCutter processes volumetric or surface data to produce cut or sliced geometry—essentially cross-sections—by intersecting the input dataset with a specified plane or surface. This resulting geometry retains scalar or vector data from the original dataset at the points of intersection. The output of vtkCutter, which may be described interchangeably as “cut geometry” or “sliced geometry,” is then passed directly to the Color Mapper. The Color Mapper uses the embedded data values (such as temperature, pressure, or other scalar fields) to determine appropriate colors for visual representation, typically by mapping data ranges to a predefined color scale or lookup table. This integration enables the effective visualization of internal structures or cross-sectional views of complex datasets, with color providing critical contextual information about the underlying data values. Together, vtkCutter and Color Mapper facilitate detailed, data-driven visual analysis by combining geometric slicing with intuitive color encoding.",
      "weight": "26.0",
      "links": "1",
      "in_context": true
    },
    {
      "id": "80",
      "source": "VTKPOLYDATANORMALS",
      "target": "COLOR MAPPER",
      "description": "The VTKPOLYDATANORMALS and COLOR MAPPER are components commonly used in the Visualization Toolkit (VTK) pipeline for rendering 3D graphics. VTKPOLYDATANORMALS refers to the vtkPolyDataNormals filter, which computes and/or corrects surface normals for polygonal data (vtkPolyData). These normals are essential for proper lighting and shading during rendering, as they define the orientation of surfaces. In the described workflow, the output of vtkPolyDataNormals—comprising both the geometric structure (vertices, polygons, etc.) and the computed normals—is passed to the COLOR MAPPER. The COLOR MAPPER, typically implemented via classes like vtkPolyDataMapper or similar mapping components in VTK, uses this input to assign colors to the geometry. Specifically, the COLOR MAPPER performs color mapping based on scalar data associated with the vtkPolyData, such as temperature, pressure, or other simulation-derived values. While vtkPolyDataNormals itself does not generate scalar data, it ensures that the geometric representation is properly prepared—with accurate normals—for downstream visualization stages. Thus, vtkPolyDataNormals provides the necessary geometric and normal information to the COLOR MAPPER, which then maps scalar values to visual colors, enabling meaningful and visually accurate representations of the underlying data. This pipeline sequence is standard in VTK-based applications where surface rendering with both proper illumination (via normals) and data-driven coloring (via scalar mapping) is required.",
      "weight": "10.0",
      "links": "1",
      "in_context": true
    },
    {
      "id": "4",
      "source": "VTKCONTOURFILTER",
      "target": "COLOR MAPPER",
      "description": "The vtkContourFilter and the Color Mapper are closely integrated components in a visualization pipeline, typically used within the Visualization Toolkit (VTK) framework. The vtkContourFilter generates contour geometry by extracting iso-surfaces or iso-lines from volumetric or structured data based on specified scalar values. This resulting geometry retains scalar data that corresponds to the original dataset’s values at the contour locations. This output from vtkContourFilter then serves as input to the Color Mapper, which maps the scalar values associated with the contour geometry to colors using a defined color transfer function or lookup table. Consequently, the contour geometry produced by vtkContourFilter is ultimately rendered with colors determined by the Color Mapper, enabling visually intuitive representations of scalar fields. In summary, vtkContourFilter provides the geometric and scalar data necessary for the Color Mapper to apply coloration, and the final visual output displays contour surfaces or lines colored according to the mapped scalar values.",
      "weight": "10.0",
      "links": "1",
      "in_context": true
    },
    {
      "id": "187",
      "source": "COLOR MAPPER",
      "target": "VTK TO BLENDER MESH.001",
      "description": "Color Mapper output is converted into a Blender mesh by VTK To Blender Mesh.001",
      "weight": "1.0",
      "links": "1",
      "in_context": true
    },
    {
      "id": "61",
      "source": "COLOR RAMP",
      "target": "MATPLOTLIB",
      "description": "Color Ramp uses colormap presets exported from Matplotlib",
      "weight": "7.0",
      "links": "1",
      "in_context": true
    }
  ],
  "claims": [],
  "sources": [
    {
      "id": "314",
      "text": "**: `m_Cross`, `m_Dash`, `m_Filled`, `m_ObjectName`, `m_Resolution`, `m_RotationAngle`, `m_Scale`, `m_Scale2`, `e_GlyphType`, `m_Center`, `m_Color`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkHyperTreeGridPreConfiguredSource\n- **bl_idname**: `VTKHyperTreeGridPreConfiguredSourceType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_ObjectName`, `m_CustomDepth`, `m_CustomDim`, `m_CustomFactor`, `m_CustomSubdivisions`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkHyperTreeGridSource\n- **bl_idname**: `VTKHyperTreeGridSourceType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_GenerateInterfaceFields`, `m_TransposedRootIndexing`, `m_UseDescriptor`, `m_UseMask`, `m_Descriptor`, `m_Mask`, `m_ObjectName`, `m_BranchFactor`, `m_MaxDepth`, `m_GridScale`, `m_Origin`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkImageCanvasSource2D\n- **bl_idname**: `VTKImageCanvasSource2DType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_ObjectName`, `m_DefaultZ`, `m_NumberOfScalarComponents`, `e_ScalarType`, `m_DrawColor`, `m_Ratio`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkImageEllipsoidSource\n- **bl_idname**: `VTKImageEllipsoidSourceType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_ObjectName`, `m_InValue`, `m_OutValue`, `e_OutputScalarType`, `m_Center`, `m_Radius`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkImageGaussianSource\n- **bl_idname**: `VTKImageGaussianSourceType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_ObjectName`, `m_Maximum`, `m_StandardDeviation`, `m_Center`\n- **connections**:\n  - **inputs**: []\n  - **outputs**:"
    },
    {
      "id": "319",
      "text": " **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkRTAnalyticSource\n- **bl_idname**: `VTKRTAnalyticSourceType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_ObjectName`, `m_SubsampleRate`, `m_Maximum`, `m_StandardDeviation`, `m_XFreq`, `m_XMag`, `m_YFreq`, `m_YMag`, `m_ZFreq`, `m_ZMag`, `m_Center`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkRandomHyperTreeGridSource\n- **bl_idname**: `VTKRandomHyperTreeGridSourceType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_ObjectName`, `m_MaxDepth`, `m_Seed`, `m_SplitFraction`, `m_Dimensions`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkRectangularButtonSource\n- **bl_idname**: `VTKRectangularButtonSourceType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_TwoSided`, `m_ObjectName`, `m_BoxRatio`, `m_Depth`, `m_Height`, `m_TextureHeightRatio`, `m_TextureRatio`, `m_Width`, `e_TextureStyle`, `m_TextureDimensions`, `m_Center`, `m_ShoulderTextureCoordinate`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkRegularPolygonSource\n- **bl_idname**: `VTKRegularPolygonSourceType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_GeneratePolygon`, `m_GeneratePolyline`, `m_ObjectName`, `m_NumberOfSides`, `m_Radius`, `m_Center`, `m_Normal`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkResizingWindowToImageFilter\n- **bl_idname**: `VTKResizingWindowToImageFilterType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_ObjectName`, `m_SizeLimit`, `e_InputBufferType`, `m_Size`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkRowQueryToTable\n- **bl_idname**: `VTKRowQueryToTable"
    },
    {
      "id": "125",
      "text": "```json\n{\n    \"links\": [\n        {\n            \"from_node_name\": \"vtkStructuredGridReader\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"vtkCutter\",\n            \"to_socket_identifier\": \"input\"\n        },\n        {\n            \"from_node_name\": \"vtkStructuredGridReader\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"vtkStructuredGridOutlineFilter\",\n            \"to_socket_identifier\": \"input\"\n        },\n        {\n            \"from_node_name\": \"vtkStructuredGridReader\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"vtkMaskPoints\",\n            \"to_socket_identifier\": \"input\"\n        },\n        {\n            \"from_node_name\": \"vtkPlane\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"vtkCutter\",\n            \"to_socket_identifier\": \"CutFunction\"\n        },\n        {\n            \"from_node_name\": \"vtkCutter\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"Color Mapper\",\n            \"to_socket_identifier\": \"input\"\n        },\n        {\n            \"from_node_name\": \"Color Ramp\",\n            \"from_socket_identifier\": \"lookupTable\",\n            \"to_node_name\": \"Color Mapper\",\n            \"to_socket_identifier\": \"lookuptable\"\n        },\n        {\n            \"from_node_name\": \"Color Mapper\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"VTK To Blender Mesh\",\n            \"to_socket_identifier\": \"input\"\n        },\n        {\n            \"from_node_name\": \"vtkStructuredGridOutlineFilter\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"vtkTubeFilter\",\n            \"to_socket_identifier\": \"input\"\n        },\n        {\n            \"from_node_name\": \"vtkTubeFilter\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"vtkPolyDataNormals\",\n            \"to_socket_identifier\": \"input\"\n        },\n        {\n            \"from_node_name\": \"vtkPolyDataNormals\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"VTK To Blender Mesh.001\",\n            \"to_socket_identifier\": \"input\"\n        },\n        {\n            \"from_node_name\": \"vtkMaskPoints\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"vtkGlyph3D\",\n            \"to_socket_identifier\": \"input 0\"\n        },\n        {\n            \"from_node_name\": \"vtkArrowSource\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"vtkGlyph3D\",\n            \"to_socket_identifier\": \"input 1\"\n        },\n        {\n            \"from_node_name\": \"vtkGlyph3D\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"Color Mapper.001\",\n            \"to_socket_identifier\": \"input"
    },
    {
      "id": "323",
      "text": "TrivialProducerType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_ObjectName`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkUniformHyperTreeGridSource\n- **bl_idname**: `VTKUniformHyperTreeGridSourceType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_GenerateInterfaceFields`, `m_TransposedRootIndexing`, `m_UseDescriptor`, `m_UseMask`, `m_Descriptor`, `m_Mask`, `m_ObjectName`, `m_BranchFactor`, `m_MaxDepth`, `m_GridScale`, `m_Origin`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkVectorText\n- **bl_idname**: `VTKVectorTextType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_ObjectName`, `m_Text`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkVideoSource\n- **bl_idname**: `VTKVideoSourceType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_AutoAdvance`, `m_ObjectName`, `m_FrameBufferSize`, `m_FrameCount`, `m_NumberOfOutputFrames`, `m_FrameRate`, `m_Opacity`, `m_StartTimeStamp`, `e_OutputFormat`, `m_FrameSize`, `m_OutputWholeExtent`, `m_DataOrigin`, `m_DataSpacing`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkWindowToImageFilter\n- **bl_idname**: `VTKWindowToImageFilterType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_FixBoundary`, `m_ReadFrontBuffer`, `m_ShouldRerender`, `m_ObjectName`, `e_InputBufferType`, `m_Scale`, `m_Viewport`\n- **connections**:\n  - **inputs**: []\n  - **outputs**: []\n  - **observers**: []\n  - **other**: []\n\n### vtkWordCloud\n- **bl_idname**: `VTKWordCloudType`\n- **module**: `generated_nodes/gen_VTKSources.py`\n- **properties**: `m_BWMask`, `m_BackgroundColorName`, `m_ColorSchemeName`, `m_FileName`, `m_FontFileName`, `m_MaskColorName`, `m_MaskFileName`, `m_ObjectName`, `m_StopListFileName`, `m_Title`,"
    },
    {
      "id": "347",
      "text": "# cubeflow_vector_glyphs\n\n生成说明\n- 本文件由脚本自动生成，来源于相同文件名的 .json\n- 结构：节点列表、连接关系、简要拓扑\n\n## 总览\n- **节点数**: 10\n- **连接数**: 9\n- **源节点**: `vtkArrowSource`, `vtkOpenFOAMReader`, `Color Ramp`\n- **汇节点**: `VTK To Blender Mesh`\n\n## 节点\n### vtkOpenFOAMReader\n- **bl_idname**: `VTKOpenFOAMReaderType`\n- **properties**: `m_AddDimensionsToArrayNames`, `m_CacheMesh`, `m_CopyDataToCellZones`, `m_CreateCellToPoint`, `m_DecomposePolyhedra`, `m_FileName`, `m_ListTimeStepsByControlDict`, `m_PositionsIsIn13Format`, `m_ReadZones`, `m_SkipZeroTime`, `m_Use64BitFloats`, `m_Use64BitLabels`\n- **extra**: `custom_code`\n\n### Time Selector\n- **bl_idname**: `BVTK_Node_TimeSelectorType`\n- **extra**: `custom_code`, `time_index`\n\n### Multi Block Leaf\n- **bl_idname**: `BVTK_Node_MultiBlockLeafType`\n- **extra**: `custom_code`, `block`\n\n### vtkCellCenters\n- **bl_idname**: `VTKCellCentersType`\n- **properties**: `m_CopyArrays`, `m_VertexCells`\n- **extra**: `custom_code`\n\n### vtkMaskPoints\n- **bl_idname**: `VTKMaskPointsType`\n- **properties**: `m_GenerateVertices`, `m_MaximumNumberOfPoints`, `m_Offset`, `m_OnRatio`, `m_ProportionalMaximumNumberOfPoints`, `m_RandomMode`, `m_RandomModeType`, `m_SingleVertexPerCell`\n- **extra**: `custom_code`\n\n### vtkArrowSource\n- **bl_idname**: `VTKArrowSourceType`\n- **properties**: `m_Invert`, `m_ShaftRadius`, `m_ShaftResolution`, `m_TipLength`, `m_TipRadius`, `m_TipResolution`\n- **extra**: `custom_code`\n\n### vtkGlyph3D\n- **bl_idname**: `VTKGlyph3DType`\n- **properties**: `m_Clamping`, `m_FillCellData`, `m_GeneratePointIds`, `m_Orient`, `m_PointIdsName`, `m_Range`, `m_ScaleFactor`, `m_Scaling`\n- **extra**: `custom_code`\n\n### Color Ramp\n- **bl_idname**: `BVTK_Node_ColorRampType`\n- **extra**: `custom_code`, `texture_name`\n\n### Color Mapper"
    },
    {
      "id": "0",
      "text": "# cubeflow_contours\n\n生成说明\n- 本文件由脚本自动生成，来源于相同文件名的 .json\n- 结构：节点列表、连接关系、简要拓扑\n\n## 总览\n- **节点数**: 8\n- **连接数**: 7\n- **源节点**: `vtkOpenFOAMReader`, `Color Ramp`\n- **汇节点**: `VTK To Blender Mesh`\n\n## 节点\n### vtkOpenFOAMReader\n- **bl_idname**: `VTKOpenFOAMReaderType`\n- **properties**: `m_AddDimensionsToArrayNames`, `m_CacheMesh`, `m_CopyDataToCellZones`, `m_CreateCellToPoint`, `m_DecomposePolyhedra`, `m_FileName`, `m_ListTimeStepsByControlDict`, `m_PositionsIsIn13Format`, `m_ReadZones`, `m_SkipZeroTime`, `m_Use64BitFloats`, `m_Use64BitLabels`\n- **extra**: `custom_code`\n\n### Time Selector\n- **bl_idname**: `BVTK_Node_TimeSelectorType`\n- **extra**: `custom_code`, `time_index`\n\n### Multi Block Leaf\n- **bl_idname**: `BVTK_Node_MultiBlockLeafType`\n- **extra**: `custom_code`, `block`\n\n### vtkAssignAttribute\n- **bl_idname**: `VTKAssignAttributeType`\n- **extra**: `custom_code`\n\n### vtkContourFilter\n- **bl_idname**: `VTKContourFilterType`\n- **properties**: `m_ArrayComponent`, `m_ComputeGradients`, `m_ComputeNormals`, `m_ComputeScalars`, `m_GenerateTriangles`, `m_NumberOfContours`\n- **extra**: `custom_code`\n\n### VTK To Blender Mesh\n- **bl_idname**: `BVTK_Node_VTKToBlenderMeshType`\n- **properties**: `m_Name`\n- **extra**: `custom_code`\n\n### Color Ramp\n- **bl_idname**: `BVTK_Node_ColorRampType`\n- **extra**: `custom_code`, `texture_name`\n\n### Color Mapper\n- **bl_idname**: `BVTK_Node_ColorMapperType`\n- **extra**: `custom_code`, `color_by`\n\n## 连接\n1. `vtkOpenFOAMReader`:`output` → `Time Selector`:`input`\n2. `Time Selector`:`output` → `Multi Block Leaf`:`input`\n3. `Multi Block Leaf`:`output` → `vtkAssignAttribute`:`input`\n4. `vtkAssignAttribute`:`output` → `vtkContourFilter`:`input`\n5. `vtkContourFilter`:`output` → `Color Mapper`:`input`\n6. `Color Ramp`:`lookupTable`"
    },
    {
      "id": "1",
      "text": "`\n4. `vtkAssignAttribute`:`output` → `vtkContourFilter`:`input`\n5. `vtkContourFilter`:`output` → `Color Mapper`:`input`\n6. `Color Ramp`:`lookupTable` → `Color Mapper`:`lookuptable`\n7. `Color Mapper`:`output` → `VTK To Blender Mesh`:`input`\n\n## 拓扑（简）\n- `Color Mapper` → `VTK To Blender Mesh`\n- `Color Ramp` → `Color Mapper`\n- `Multi Block Leaf` → `vtkAssignAttribute`\n- `Time Selector` → `Multi Block Leaf`\n- `vtkAssignAttribute` → `vtkContourFilter`\n- `vtkContourFilter` → `Color Mapper`\n- `vtkOpenFOAMReader` → `Time Selector`\n\n"
    },
    {
      "id": "11",
      "text": "```json\n{\n    \"links\": [\n        {\n            \"from_node_name\": \"vtkOpenFOAMReader\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"Time Selector\",\n            \"to_socket_identifier\": \"input\"\n        },\n        {\n            \"from_node_name\": \"Time Selector\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"Multi Block Leaf\",\n            \"to_socket_identifier\": \"input\"\n        },\n        {\n            \"from_node_name\": \"Multi Block Leaf\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"vtkCellCenters\",\n            \"to_socket_identifier\": \"input\"\n        },\n        {\n            \"from_node_name\": \"vtkCellCenters\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"vtkMaskPoints\",\n            \"to_socket_identifier\": \"input\"\n        },\n        {\n            \"from_node_name\": \"vtkMaskPoints\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"vtkGlyph3D\",\n            \"to_socket_identifier\": \"input 0\"\n        },\n        {\n            \"from_node_name\": \"vtkArrowSource\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"vtkGlyph3D\",\n            \"to_socket_identifier\": \"input 1\"\n        },\n        {\n            \"from_node_name\": \"vtkGlyph3D\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"Color Mapper\",\n            \"to_socket_identifier\": \"input\"\n        },\n        {\n            \"from_node_name\": \"Color Ramp\",\n            \"from_socket_identifier\": \"lookupTable\",\n            \"to_node_name\": \"Color Mapper\",\n            \"to_socket_identifier\": \"lookuptable\"\n        },\n        {\n            \"from_node_name\": \"Color Mapper\",\n            \"from_socket_identifier\": \"output\",\n            \"to_node_name\": \"VTK To Blender Mesh\",\n            \"to_socket_identifier\": \"input\"\n        }\n    ],\n    \"nodes\": [\n        {\n            \"bl_idname\": \"VTKOpenFOAMReaderType\",\n            \"color\": [\n                0.5,\n                0.5,\n                0.5\n            ],\n            \"custom_code\": \"\",\n            \"height\": 100.0,\n            \"hide\": false,\n            \"label\": \"\",\n            \"location\": [\n                -550.0,\n                250.0\n            ],\n            \"m_AddDimensionsToArrayNames\": false,\n            \"m_CacheMesh\": true,\n            \"m_CopyDataToCellZones\": false,\n            \"m_CreateCellToPoint\": true,\n            \"m_DecomposePolyhedra\": false,\n            \"m_FileName\": \"$/cubeflow/case.foam\",\n            \"m_ListTimeStepsByControlDict\": false,\n            \"m_PositionsIsIn13Format"
    },
    {
      "id": "35",
      "text": "* node in\nexample above.\n\n## Extract Boundary Surfaces\n\n*VTK To Blender Mesh* node extracts all boundary surfaces.\n\n![image](images/vtk_to_blender_mesh_node.png)\n\nFor forks other than\n[tkeskita/bvtknodes](https://github.com/tkeskita/BVtkNodes) you can use\n*vtkGeometryFilter* followed by the legacy *VTK To Blender* node.\n**Note**: This may not produce correct results for polyhedron meshes.\n\n![image](images/ug_boundary_nodesetup.png)\n\nIf you want to extract a single boundary patch for OpenFOAM case, you\nneed to\n\n- Add `EnableAllPatchArrays()` Custom Code to *vtkOpenFOAMReader* (see\n  `custom_code`).\n- Add two *Multi Block Leaf* nodes in series to select patches and the\n  wanted patch, before connecting to *VTK To Blender Mesh*.\n- Run *Update Node* and *Force Update Upstream* on *VTK To Blender Mesh*\n  node to make the `EnableAllPatchArrays()` work correctly.\n\nThis node tree example name is *cubeflow_boundary_patch*.\n\n![image](images/ug_extract_boundary_patch_nodesetup.png)\n\n## Field Data Calculations\n\nYou can use *vtkArrayCalculator* to calculate new fields from existing\nfields.\n\n- In *vtkArrayCalculator* node, write the calculator code to\n  **Function** field, the result array name to **ResultArrayName**, and\n  select correct type for the **AttributeType** field. Disable\n  **Coordinate Results**. Finally you must specify the array names which\n  are operated on by Custom Code like:\n\n      AddVectorArrayName(\"U\")\n\n- See [the list of operators in vtkArrayCalculator\n  docs](https://vtk.org/doc/nightly/html/classvtkArrayCalculator.html#details).\n  Some examples for **Function** field:\n\n  - First *U* vector component can be extracted by expression like\n    `dot(U,iHat)` (old syntax `U.iHat` does not work any more)\n  - *U* vector magnitude can be calculated with `mag(U)`\n\n![image](images/ug_array_calculator_nodesetup.png)\n\n## Cutting Field Data\n\nUse *vtkCutter* in combination with a geometry generator (like\n*vtkPlane*) to slice your field data. Combine with *Color Mapper* and\n*Color Ramp* to color by field value. The name of this example node tree\nis *cubeflow_cut_plane*.\n\n- Connect *vtkPlane* to the **CutFunction** connector on the *vtkCutter*\n  node.\n- Disable **GenerateCutScalars** and **GenerateTriangles** in\n  *vtkCutter* node.\n- Connect *Color Ramp* to the **lookuptable** connector in the *Color\n  Mapper* node.\n"
    },
    {
      "id": "36",
      "text": "*\n  node.\n- Disable **GenerateCutScalars** and **GenerateTriangles** in\n  *vtkCutter* node.\n- Connect *Color Ramp* to the **lookuptable** connector in the *Color\n  Mapper* node.\n- In the *VTK To Blender Mesh* node, you must enable **Generate\n  Material**, so that result colors will be shown after final Update.\n  Note: 3D Viewport must be in *Material Preview* or *Rendered* mode to\n  see the colors.\n- Run *Update Node* on the *VTK To Blender Mesh* node.\n\n![image](images/ug_cut_plane_nodesetup.png)\n\nHere is the result in 3D Viewport shown in Material Preview Mode:\n\n![image](images/ug_cut_plane_result.png)\n\nNote that the *Color Ramp* now features several color map presets,\nexported from\n[matplotlib](https://matplotlib.org/stable/tutorials/colors/colormaps.html).\nThe number of color values determine how closely the *Color Ramp* will\nmatch the underlying colormap (up to 32 samples are possible). Together\nwith constant interpolation mode, this can create a contour-like effect\non the surface.\n\n## Vector Glyphs\n\nGlyphs (like one produced by *vtkArrowSource*) can be placed at points,\noriented and scaled by *vtkGlyph3D* node. This node tree example named\n*cubeflow_vector_glyphs* shows how to color glyphs by velocity\nmagnitude.\n\n- Add *vtkCellCenters* node to get points of cell centers.\n- Add *vtkMaskPoints* node, and adjust **MaximumNumberOfPoints** to a\n  small value and set **OnRatio** to 1 (no skipping of data points). It\n  is good idea to use a small value for maximum number of points while\n  tuning, so that calculation does not take a long time.\n- Add *vtkGlyph3D* node, and set **ScaleFactor** to 0.5, **ColorMode**\n  to ColorByVector, and **ScaleMode** to DataScalingOff.\n- Connect *vtkArrowSource* to **input 1**, and add *Color Mapper*,\n  *Color Ramp*, and *VTK To Blender Mesh* (with Generate Material\n  enabled).\n- Run *Update Node* on the final node.\n\n> [!NOTE]\n> If the glyphs are all incorrectly aligned along the positive X-axis\n> even when *Orient* is on, you need to add *vtkAssignAttribute* node\n> e.g. before *vtkMaskPoints*. You need to add Custom Code (see\n> `custom_code`) to specify a data array to be activated, e.g.\n> `Assign(\"U\", vtk.vtkDataSetAttributes.VECTORS, vtk.vtkAssignAttribute.POINT_DATA)`\n\n![image](images/ug_glyphs_nodeset"
    }
  ]
}